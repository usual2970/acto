# Implementation Plan: Points System

**Branch**: `001-` | **Date**: 2025-10-15 | **Spec**: `/specs/001-/spec.md`
**Input**: Feature specification from `/specs/001-/spec.md`

**Note**: This plan is generated by `/speckit.plan` using the provided template and the constitution.

## Summary

Primary requirement: implement a multi-type integer points system with balance operations, history, rankings, rank-based reward distribution, and redemption, available both as a standalone REST HTTP service and as an embeddable Go library sharing the same business logic.

Technical approach: Clean Architecture with domain/use case separation, PostgreSQL for persistence, Redis ZSET for real-time rankings, RESTful APIs with OpenAPI documentation, and typed errors in library mode. Concurrency safety via Read Committed transactions with row-level locks. Authorization is role-based (admin/end-user). All point values are integers; no decimals.

## Technical Context

**Language/Version**: Go 1.20  
**Primary Dependencies**: Standard library (`net/http`), router (`gorilla/mux`), SQL driver (`go-sql-driver/mysql`), Redis client (`go-redis`), OpenAPI tool (NEEDS CLARIFICATION)  
**Storage**: MySQL (primary system of record); Redis (rankings via ZSET)  
**Testing**: `go test`, `testify`, mocks via `mockery`; repository integration tests with ephemeral MySQL/Redis (Docker)  
**Target Platform**: Linux server (containerized) for service; any Go-compatible host for library  
**Project Type**: Single backend service/library (no frontend)  
**Performance Goals**: p95 < 100ms for credit/debit; ranking generation < 5s for 100k users; real-time ranking updates < 100ms  
**Constraints**: Clean Architecture layering; ≥80% coverage for critical logic; minimal external deps; error codes consistent; integer-only arithmetic  
**Scale/Scope**: 10k DAU; 500 concurrent tx peak; 1M transactions stored; 100+ rewards in catalog

Unknowns marked NEEDS CLARIFICATION will be resolved in Phase 0 research.

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

- Clean Architecture layers defined: domain, use case (service), repository, delivery – PASS
- Interfaces declared at consumer side – PASS
- Test-first development with coverage ≥80% – PASS
- Framework independence of business logic – PASS
- REST standards and consistent error responses – PASS
- Dependency management, linting, CI gates per constitution – PASS

Re-check after Phase 1 design:
- OpenAPI defined for REST endpoints – PASS
- Data model adheres to domain purity (no external deps) – PASS
- Repository and delivery concerns isolated under `internal/` – PASS
- Error handling model mapped: domain errors ↔ HTTP codes – PASS

Status: PASS. No violations require justification.

## Project Structure

### Documentation (this feature)

```
specs/001-/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output (/speckit.plan command)
├── data-model.md        # Phase 1 output (/speckit.plan command)
├── quickstart.md        # Phase 1 output (/speckit.plan command)
└── contracts/           # Phase 1 output (/speckit.plan command)
```

### Source Code (repository root)

```
app/
└── main.go

domain/
└── points/

points/
├── service.go
└── mocks/

internal/
├── repository/
│   ├── mysql/
│   └── redis/
└── rest/
    ├── handlers/
    └── middleware/

tests/
├── unit/
├── integration/
└── contract/
```

**Structure Decision**: Single backend project following the constitution’s Go clean architecture layout. Domain in `domain/`, use cases in `points/`, infra in `internal/` with `repository/` and `rest/`, entrypoint in `app/`.

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
